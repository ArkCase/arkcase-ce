- name: install pyOpenSSL
  become: yes
  pip:
    name: pyOpenSSL

- name: create pki folder structure
  become: yes
  file:
    path: "{{ item }}"
    state: directory
  loop:
    - "/etc/tls"
    - "/etc/tls/private"
    - "/etc/tls/csr"
    - "/etc/tls/crt"
    - "/etc/tls/ca"

# Generate an OpenSSL private key with the default values (4096 bits, RSA)
- name: generate root ca private key
  become: yes
  openssl_privatekey:
    path: "/etc/tls/private/arkcase-root.pem"
    type: RSA
    size: 4096

- name: generate root ca certificate signing request
  become: yes
  openssl_csr:
    basic_constraints_critical: yes
    basic_constraints:
      - CA:TRUE
    key_usage_critical: yes
    key_usage:
      - Digital Signature
      - Certificate Sign
      - CRL Sign
    digest: sha256
    path: "/etc/tls/csr/arkcase-root.csr"
    privatekey_path: "/etc/tls/private/arkcase-root.pem"
    country_name: US
    state_or_province_name: VA
    locality_name: Vienna
    organization_name: ArkCase
    organizational_unit_name: Product Development
    common_name: root.{{ arkcase_host_name }}
    email_address: info@arkcase.com
  register: root_csr

- name: Sign root ca certificate
  become: yes
  openssl_certificate:
    path: "/etc/tls/ca/arkcase-root.crt"
    privatekey_path: "/etc/tls/private/arkcase-root.pem"
    csr_path: "/etc/tls/csr/arkcase-root.csr"
    provider: selfsigned
  when: root_csr is changed
  register: root_cert

- name: generate intermediate private key
  become: yes
  openssl_privatekey:
    path: "/etc/tls/private/arkcase-intermediate.pem"
    type: RSA
    size: 4096
  register: intermediate_private_key

# NOTE the intermediate CSR is signed with the intermediate key
- name: generate intermediate csr
  become: yes
  openssl_csr:
    basic_constraints_critical: yes
    basic_constraints:
      - CA:TRUE
      - pathlen:0
    key_usage_critical: yes
    key_usage:
      - Digital Signature
      - Certificate Sign
      - CRL Sign
    digest: sha256
    path: "/etc/tls/csr/arkcase-intermediate.csr"
    privatekey_path: "/etc/tls/private/arkcase-intermediate.pem"
    country_name: US
    state_or_province_name: VA
    locality_name: Vienna
    organization_name: ArkCase
    organizational_unit_name: Product Development
    email_address: info@arkcase.com
    common_name: intermediate.{{ arkcase_host_name }}
  register: intermediate_csr

# the intermediate cert is signed with the root key
# ownca provider makes it so the issuer of this certificate
# is the root cert... "selfsigned" provider means the cert
# is always self-signed (issuer same as subject).
- name: Sign intermediate CSR
  become: yes
  openssl_certificate:
    path: "/etc/tls/crt/arkcase-intermediate.crt"
    ownca_path: "/etc/tls/ca/arkcase-root.crt"
    ownca_privatekey_path: "/etc/tls/private/arkcase-root.pem"
    csr_path: "/etc/tls/csr/arkcase-intermediate.csr"
    provider: ownca
  when: intermediate_csr is changed
  register: intermediate_cert

- name: generate the chain cert file
  become: yes
  shell: cat /etc/tls/crt/arkcase-intermediate.crt /etc/tls/ca/arkcase-root.crt > /etc/tls/crt/arkcase-chain.crt
  when: intermediate_cert is changed or root_cert is changed

# Although 4096 bits is slightly more secure than 2048 bits,
# it slows down TLS handshakes and significantly increases
# processor load during handshakes. For this reason, most
# websites use 2048-bit pairs.
- name: generate server private key
  become: yes
  openssl_privatekey:
    path: "/etc/tls/private/arkcase-server.pem"
    type: RSA
    size: 2048
  register: server_private_key

- name: write server private key in RSA format, for MySQL et. al.
  become: yes
  command: openssl rsa -in "/etc/tls/private/arkcase-server.pem" -out "/etc/tls/private/arkcase-server.rsa.pem"
  when: server_private_key is changed

- name: generate server csr
  become: yes
  openssl_csr:
    basic_constraints_critical: no
    basic_constraints:
      - CA:FALSE
    key_usage_critical: yes
    key_usage:
      - Digital Signature
      - keyEncipherment
    extended_key_usage_critical: no
    extended_key_usage:
      - serverAuth
    digest: sha256
    path: "/etc/tls/csr/arkcase-server.csr"
    privatekey_path: "/etc/tls/private/arkcase-server.pem"
    country_name: US
    state_or_province_name: VA
    locality_name: Vienna
    organization_name: ArkCase
    organizational_unit_name: Product Development
    email_address: info@arkcase.com
    common_name: "{{ arkcase_host_name }}"
    subject_alt_name:
      - DNS:{{ external_host }}
      - DNS:{{ internal_host }}
      - DNS:acm-activemq
  register: server_csr

# the server cert is signed with the intermediate key
- name: Sign server CSR
  become: yes
  openssl_certificate:
    path: "/etc/tls/crt/arkcase-server.crt"
    ownca_path: "/etc/tls/crt/arkcase-intermediate.crt"
    ownca_privatekey_path: "/etc/tls/private/arkcase-intermediate.pem"
    csr_path: "/etc/tls/csr/arkcase-server.csr"
    provider: ownca
  when: server_csr is changed

# client key, for MariaDB which wants a separate key for clients and server  
- name: generate client private key
  become: yes
  openssl_privatekey:
    path: "/etc/tls/private/arkcase-client.pem"
    type: RSA
    size: 2048
  register: client_private_key

- name: write client private key in RSA format, for MySQL et. al.
  become: yes
  command: openssl rsa -in "/etc/tls/private/arkcase-client.pem" -out "/etc/tls/private/arkcase-client.rsa.pem"
  when: client_private_key is changed

- name: generate client csr
  become: yes
  openssl_csr:
    basic_constraints_critical: no
    basic_constraints:
      - CA:FALSE
    key_usage_critical: yes
    key_usage:
      - nonRepudiation
      - digitalSignature
      - keyEncipherment
    extended_key_usage_critical: no
    extended_key_usage:
      - clientAuth
      - emailProtection
    digest: sha256
    path: "/etc/tls/csr/arkcase-client.csr"
    privatekey_path: "/etc/tls/private/arkcase-client.pem"
    country_name: US
    state_or_province_name: VA
    locality_name: Vienna
    organization_name: ArkCase
    organizational_unit_name: Product Development
    email_address: info@arkcase.com
    common_name: "{{ arkcase_host_name }}"
    subject_alt_name:
      - DNS:{{ external_host }}
      - DNS:{{ internal_host }}
      - DNS:acm-activemq
  register: client_csr

# the client cert is signed with the intermediate key
- name: Sign client CSR
  become: yes
  openssl_certificate:
    path: "/etc/tls/crt/arkcase-client.crt"
    ownca_path: "/etc/tls/crt/arkcase-intermediate.crt"
    ownca_privatekey_path: "/etc/tls/private/arkcase-intermediate.pem"
    csr_path: "/etc/tls/csr/arkcase-client.csr"
    provider: ownca
  when: client_csr is changed

- name: Java keystore and trust store
  block:
    - name: see if the Java keystore exists
      become: yes
      stat:
        path: "{{ root_folder }}/common/arkcase.ks"
      register: arkcase_ks_stat
      changed_when: false
    - name: see if keys already added to the Java keystore
      become: yes
      command: keytool -v -list -keystore {{ root_folder }}/common/arkcase.ks -storepass {{ java_key_store_pass }}
      when: arkcase_ks_stat.stat.exists == True
      register: key_out
      changed_when: false
    - name: write Java key store and trust store
      block:
        - name: write arkcase.p12 (used by Pentaho)
          become: yes
          command: openssl pkcs12 -export -in "/etc/tls/crt/arkcase-client.crt" -inkey "/etc/tls/private/arkcase-client.pem" -out {{ root_folder }}/common/arkcase-client.p12 -name arkcase -chain -CAfile "/etc/tls/crt/arkcase-chain.crt" -passout 'pass:{{ java_key_store_pass  }}'
        - name: copy arkcase.p12 to key store format
          become: yes
          command: keytool -importkeystore -deststorepass {{ java_key_store_pass }} -destkeypass {{ java_key_store_pass }} -destkeystore {{ root_folder }}/common/arkcase.ks -deststoretype pkcs12 -srckeystore {{ root_folder }}/common/arkcase-client.p12 -srcstoretype pkcs12 -srcstorepass {{ java_key_store_pass }} -alias arkcase
        - name: add ArkCase certs to Java truststore
          become: yes
          java_cert:
            cert_alias: "{{ item.alias }}"
            cert_path: "{{ item.path }}"
            keystore_path: "{{ root_folder }}/common/arkcase.ts"
            keystore_pass: "{{ java_trust_store_pass }}"
            keystore_create: yes
            state: present
          loop:
            - alias: "arkcase-client"
              path: "/etc/tls/crt/arkcase-client.crt"
            - alias: "arkcase-chain"
              path: "/etc/tls/crt/arkcase-chain.crt"
        - name: add JDK certs to Java trust store
          become: yes
          command: keytool -importkeystore -srckeystore /usr/lib/jvm/java-1.8.0-openjdk/jre/lib/security/cacerts -srcstorepass changeit -destkeystore {{ root_folder }}/common/arkcase.ts -deststorepass {{ java_trust_store_pass }} -noprompt
      when: "arkcase_ks_stat.stat.exists == False or 'arkcase' not in key_out.stdout"

- name: write encrypted symmetric key file for use in ArkCase webapp
  block:
    - name: check if symmetric key file exists
      become: yes
      stat:
        path: "{{ root_folder }}/common/symmetricKey.encrypted"
      register: sym_key_enc
      changed_when: false
    - name: write plaintext key
      become: yes
      copy:
        dest: "{{ root_folder }}/common/symmetricKey.txt"
        content: |
          {{ 9999999999999999999999 | random | to_uuid }}
      when: sym_key_enc.stat.exists == False
    - name: extract public key from client cert
      become: yes
      command: openssl x509 -pubkey -noout -in "/etc/tls/crt/arkcase-client.crt" -noout
      register: client_pub_key
      when: sym_key_enc.stat.exists == False
      changed_when: false
    - name: write public key to file
      become: yes
      copy:
        dest: "{{ root_folder }}/common/arkcase-client.pub"
        content: |
          {{ client_pub_key.stdout }}
      when: sym_key_enc.stat.exists == False
    - name: write encrypted plaintext
      become: yes
      command: openssl rsautl -encrypt -pubin -inkey {{ root_folder }}/common/arkcase-client.pub -in {{ root_folder }}/common/symmetricKey.txt -out {{ root_folder }}/common/symmetricKey.encrypted
      when: sym_key_enc.stat.exists == False


